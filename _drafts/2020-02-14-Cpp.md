---
layout: blog
title: C 与 C++
permalink: /blog/C&Cpp.html
date: 2020-02-14 01:06:00 +0800
category: 开发
tags: 
---

> **参见**
>
> *Stanley B Lippman - The C Progamming Language, 1988* ，C 权威学习书籍。
>
> *Stanley B Lippman - C++ Primer 5th Edition, 2012*，C++ 11 权威学习书籍。
>
> [C++ Reference](https://en.cppreference.com/)，C/C++ 参考手册。
>
> [Microsoft Docs](https://docs.microsoft.com/) - [C++ Language Reference](https://docs.microsoft.com/en-us/cpp/cpp/cpp-language-reference), [Standard Library Reference](https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-reference)，微软的 C++ 语言与标准库参考。
>
> [Standard C++](https://isocpp.org/) ，标准 C++ 官方网站。

[TOC]

# 工作原理

编译 - 链接 - 运行。

# 现代C++新特性

C++98 在广泛使用很长事件后，C++11 。

# 词法

## 令牌

C++ 代码由令牌（Token）和间隔构成。令牌是代码里的最小有意义单位。如 `std::out << "Hello World!" << std::endl;` 共有 10 个令牌：`std` 、`::` 、`out` 、`<<` 、`"Hello Horld!"` 、`<<` 、`std` 、`::` 、`endl` 、`;` 。

编译时，语法分析器识别的令牌类型分为：[关键字][]，[标识符][]，[字面值][]，[运算符][]，标点符号 。

令牌之间有间隔，可以是空格、制表符、换行符、换页符、注释。

# 关键字

[关键字]: 关键字	"Keyword"

C：

* 类型相关：`bool` `char` `int` `double` `float` 
* 控制相关：`if  ` `switch`  `for` `do` `while` 

C++新增：



# 标识符
[标识符]:#标识符
标识符，identifier，用于给类型、变量、函数的命名。规则：

* 

# 字面值

[字面值]:#字面值

Literal，字面值，直接用字符描述的数据常量，常被用于给变量赋值 、作为参数。

## 整数字面值

整数字面值：默认是 `int` 型十进制。前缀表示为类型或其他进制。

> ```c++
>10;		// 十进制10 
> 0x10;	// 十六进制10 ，等于十进制16
> 0b10;	// 二进制10 ，等于十进制2
> -10;	// 带有负号运算符的字面值10，因为严格意义上字面值不会是负数。
> 
> ```

## 小数字面值

> 小数字面值：。默认是 `double` 型。前缀表示为类型或其他进制。
>
> ```c++
> 
> ```

## 文本字面值

文本字面值：' ' 内为字符；" " 内为字符串。

> ```C++
>
> ```

转义符 `/` 用于描述。

## 指针字面值

只有C++空指针 `nullptr` 一种。

# 注释

注释，Comment。

```c++
// 这是行注释

/*
 这是
 块注释
*/
```

# 类型与对象

🛠各个对象本质上都是一些二进制值，类型是解读这些值的方式。

对象（object）是实体（entity）的一种，。

内置类型（Build-In Types），是C/C++语言的关键字，不依赖头文件的定义，编译器自动支持。

## 无类型

void 

## 整型

整数类型，integral。🛠存储原理：对于占 n 个 bit 的存储整数型：若没有 `unsigned` 修饰，则首位作为正负标志位，1表示负数，0表示正数，后面的位表示绝对值大小，范围是 $-2^{n-1}$ ~ $2^{n-1}-1$；若有 `unsigned` 修饰，所有位都用于表示大小，范围是 $0$ ~ $2^n-1$。整型以补码的形式存储整数，例如 -1 的1字节二进制为 0xFF。

|         类型         | 描述                                                         |    占用    |             取值范围             |
| :------------------: | ------------------------------------------------------------ | :--------: | :------------------------------: |
|        `bool`        | 0为 false，非0为 true。                                      |   1 Byte   |        `true` 或 `false`         |
|        `char`        | 因为7 bit的ASCII常用1字节来存储，所以1字节的整数又字符型（character）。 |   1 Byte   |            -128 ~ 127            |
|   `unsigned char`    |                                                              |   1 Byte   |              0~256               |
|        `int`         |                                                              |  机器位长  | -2147483648 ~ 2147483647 (32bit) |
|    `unsigned int`    |                                                              |  机器位长  |     0 ~ 4,294,967,295(32bit)     |
|       `short`        |                                                              | \>= 2 Byte |                                  |
|   `unsigned short`   |                                                              | \>= 2 Byte |                                  |
|        `long`        |                                                              | \>= 4 Byte |                                  |
|   `unsigned long`    |                                                              | \>= 4 Byte |                                  |
|     `long long`      |                                                              | \>= 8 Byte |                                  |
| `unsigned long long` |                                                              | \>= 8 Byte |                                  |

由于 `short` 和 `long` 在 C 语言只要求了最小长度，若对长度有具体要求（有更好的可移植性），则使用 `uint_16` 等类型。

## 浮点型

浮点型，floating point。存储原理：

## typedef 定义类型别名

用来给已有的类型去一个新名字，可以避免直接使用原类型名，令表述更简洁。

```c++
typedef std::map<std::string, unsigned int> NameToAgeMap;
```

## C auto 与 C++ auto 

C 的 `auto` 关键字。

C++ 的 `auto` 关键字在 C++11 引入，用于让编译器自动推断类型。

> 用 `auto` 替代复杂的类型名，使代码更简洁：
>
> ```c++
> std::vector<string> colors = {"red", "blue", "green"};
> for(auto colorItr = colors.begin(); colorItr!= colors.end(); colorItr++)
> {
>     // auto 被编译器推断为 std::vector<string>::iterator 类型
> }
> ```

## const常量修饰符

[const]:#const常量修饰符	" "

1. 用于修饰一经创建就不可修改的常量。用`const` 修饰的常量，相比 `#define` 宏定义的文本替换，具有类型检查的优点。

```c++
const double PI = 3.141592653;
```

2. 用于修饰

> `const char*`,  `char const*`, `char* const` 的区别
>
> 

## static静态

[static]: #static静态

被 `static` 说明符修饰的变量，存储在静态存储区，在整个程序运行期间一直存在。定义的

# 定义

以下情况视为**单纯声明，不定义**：

```c++
// 没有函数体的函数。
int f(int); 

// extern 修饰符，且没有赋值。
extern const int a; 


```



# 命名空间

> 

左值与右值。



# 指针

[指针]:#指针

> ```c++
>int myAge = 23;
> int *ptrMyAge; 		// '*' 用于声明变量是指针类型
> ptrMyAge = &myAge; 	// '&' 用于获取变量的地址
> *ptrMyAge = 24;		// '*' 用于获取指针指向的对象
> ```

# 引用

[引用]: #引用

引用，Reference，是 C++ 语法做的优化。本质上，在编译后**还是靠指针**来实现的。对引用操作相当于对其本身操作。

# 字符与字符串

## 字符串类型

抽象程度越来越高。

### C - 字符数组与指针

在 C 语言中，字符串就是以 `\n` 结束的字符数组。 

`"String Content"` 字面值 。

### C 标准库 - `string` 

### C++ 标准库 - `std::string` 

## 字符串类型转换

|                        | to `char[]` | to `char*` | to `const char*` | to `string` | to `std::string` |
| ---------------------- | :---------: | :--------: | :--------------: | :---------: | ---------------- |
| **from** `char[]`      |      -      |            |                  |             |                  |
| **from** `char*`       |             |     -      |                  |             |                  |
| **from** `const char*` |             |            |        -         |             |                  |
| **from** `string`      |             |            |                  |      -      |                  |
| **from** `std::string` |             |            |                  |             |                  |

# 集合类型

同种类型的多个对象构成的对象。

## 数组

数组，array。数组成员在内存上连续分布，常常配合指针的偏移访问数组成员。

### 

# 语句

语句，statement，是顺序执行的程序段。声明不是语句，因为不会有程序被执行。

## 语句的标号

标号，label，`语句的标号名: 语句内容` 。与 `goto` 、`case` 配合使用。

## 复合型

，又称块 block，由 `{ }` 括起来的多条语句构成。函数体

## 表达式型

## 选择型



## 迭代型

## 跳转型

`break;` 跳出当前的循环。

`continue;` 

`return 可选的表达式;`  

`goto 语句的标号;`  用于跳。

# 表达式

表达式是执行的运算。表达式可以构成。

# 函数

函数是有具体用途的自包含的**代码块**。函数也是对象，有类型、名、值。

* 函数的**类型**取决于**参数列表与返回类型**。
* 函数的实例对象**名称**取决于**函数名**。用来被标识与调用。
* 函数的**定义**取决于**函数体**。

```C++
// 定义一个函数
std::string greet(std::string person)
{
    return "Hello" + person + "!";
}

// 调用此函数
std::cout << greet("Anna");	// 输出 "Hello, Anna!"
std::cout << greet("Brian"); // 输出 "Hello, Brian!"
```

函数声明，功能为：给外部提供调用接口。虽然参数列表可以省略参数名，但不建议，最好与函数定义保持一致。

## 参数

函数定义时的参数称为形式参数（parameter，形参）；函数被调用时传入的参数称实际参数（argument，实参）。

### 

### 可变参数表

### 传值与传引用

### 默认参数

## 返回

返回语句`return` 直接结束运行函数。

如果函数定义返回值的类型，，`return expression;`。

位于无返回值函数末尾的 `return;` 语句可以省略。

## 函数重载

## 调用栈

## 内联函数

## 友元函数

# λ表达式

λ表达式，Lambda Expression，于 C++ 11 引入，在编程领域又名：匿名函数（Anonymous Functions）、闭包（Closure）。λ表达式之于函数，类似于字面值之于变量，都是有值无名的某个对象。

# 枚举

# 联合体

# 类和结构体

类与结构体

C 中结构体用于将。

C++ 中类与结构体。

## 嵌套类

嵌套类，Nested Class，指此类在其他类里定义。嵌套类是静态成员。

## 成员与成员函数

类或结构体

## 访问控制

## 继承

## 构造

```c++
struct Fahrenheit
{
    double temperature;
    Fahrenheit(double Celsius)
}
```

### 初始化列表

### 拷贝构造

### 移动构造

## 析构

## 虚函数与多态

多态的核心理念：通过基类访问派生类定义的函数（允许用**基类的指针调用派生类**的此**函数**）。

### 虚函数表

## 纯虚函数&抽象类&接口

通过定义**抽象类**（abstract class, ABC），设计**接口**（interface），类似于Swift语言的协议。抽象类**只能**用于**派生**，**不能**用于**创建实例**。抽象类至少有一个**纯虚函数（）**，只声明类型，**不做具体实现**，语法 `virtual int f(int p) = 0`。只有重写实现了虚函数的派生类才能用于创建实例。

# 类型转换

使用以 `(typeName) variable` 形式，实现显式地类型转换。



# 模板

[模板]:#模板

模板（Template），是实现泛型编程（Generic）的具体手段。

## 函数模板

```c++
template< typename T > void MySwap( T& a, T& b ) {
   T c(a);
   a = b;
   b = c;
}
```

关键字 `typename` 也可以用 `class` 替换，但是 `class` 有自定义类型的。

## 类模板

[类模板]:#模板

 

# 作用域

# 运算符

[运算符]:#运算符

## 运算符重载

# 标准模板库容器

[标准模板库容器]:#标准模板库容器

C++的，标准模板库容器，Standard Template Library Container，STL Container ，是用于管理和组织其他对象的对象，基于模板实现。包括两种：

1. 顺序容器，Sequence Containers ，根据**位置**管理元素。包括 vector。
2. 关联容器，Associative Containers，根据**键（Key）**管理元素。包括 set、map。

## vector

[vector]:#vector

头文件 [\<vector\>](https://docs.microsoft.com/en-us/cpp/standard-library/vector) 。可变大小，可任意位置增删成员，综合性能最好。

工作原理：。

> 初始化
>
> ```c++
> // 定义空容器
> std::vector<int> v1;
> // C++ 11 new: 初始化并赋值
> std::vector<int> v1 = {1,2,3,4,5};
> // 用迭代器初始化
> std::set<int> s1 = {9, 8, 7, 6, 5, 4, 3};   // 3 4 5 6 7 8 9
> std::vector<int> v1(s1.begin(), s1.end());  // 3 4 5 6 7 8 9
> 
> ```
>
> 更新
>
> ```
> 
> ```
>
> 

## array

## set

关联容器共计8种类型，从3个维度区分：

* 是可通过 key 访问 value 的 `map` 还是 value 就是 key 本身的 `set` 。
* `multi`前缀表示 key 能否重复。
* `unordered`前缀表示成员是否有序。

头文件 [\<set\>](https://docs.microsoft.com/en-us/cpp/standard-library/set)  \<[map](https://docs.microsoft.com/en-us/cpp/standard-library/map)\>  \<[unordered_set](https://docs.microsoft.com/en-us/cpp/standard-library/unordered-set)\>  \<[unordered_map](https://docs.microsoft.com/en-us/cpp/standard-library/unordered-map)\> 

iterator 是 const 的：这意味着不能用诸如 `std::copy` 等算法他们操作。

严格若序的，

`std::set` 存储已排序对象，默认对 Key 依据 `<` 运算符排序。

```c++
// 定义一个 set 对象

std::vector<int> v1 = {9, 9, 8, 8, 8, 7, 7, 6, 5, 4, 3, 3}; // 原数据成员无序且存在重复成员
std::set<int> s1(v1.begin(), v1.end());		// 会自动排序 {9, 8, 7, 6, 5, 4, 3}

// 定义一个 map 对象
set::map<pair<std::string, int>> 
```

若成员是自定义类型 ，必须对 Key 重载`<`运算符。因为成员严格，若有 `a < b == false && b < a == false` ，则 `a == b` 。所以通过重载 `<` 运算符实现唯一性。

```c++
struct Box
{
    double length;
    double width;
    double height;
    double volume;
    Box(double l, double w, double h) : length(l), width(w), height(h)
    {
        volume = l * w * h;
    }
    bool operator<(const Box &other) const { return volume < (other.volume); }
};

std::set<Box> SomeBoxes;
Box box1(5, 7, 8);
SomeBoxes.insert(box1);
Box box2(8, 7, 5);
SomeBoxes.insert(box2); // box1 == box2 in the set according to operator<
Box box3(7, 7, 7);
SomeBoxes.insert(box3);
Box box4(10, 14, 16);
SomeBoxes.insert(box4);
Box box5(3, 3, 3);
SomeBoxes.insert(box5);
```

自定义比较函数

```c++

```

> 遍历
>
> 查找：`find` 。
>
> ```c++
> std::set<int> evenNumbers = {0,2,4,6,8,10};
> if (evenNumber.find(5) == evenNumbers.end())
> std::cout << "Can't find 5 in evenNumber" << std::endl;
> else
> std::cout << "Can find 5 in evenNumber" << std::endl;
> ```
>
> 计数：`count` 。
>
> 添加：`insert` 。
>
> 删除：`erase` 。
>
> ```c++
> std::set<int> evenNumbers = {0,2,4,6,8,10};
> for(std::set<int>::iterator itr = ;;)
> {
> 
> }
> ```
>
> 

## map

```c++
typedef std::string Poet;    
typedef std::string Poem;    
std::multimap<Poet, Poem> poemCollection;
   
poemCollection.insert(std::pair<"李白", "将进酒">);
poemCollection.insert(std::pair<"李白", "蜀道难">);
poemCollection.insert(std::pair<"白居易", "琵琶行">);
poemCollection.insert(std::pair<"", "">);
```



无序关联容器是 C++ 11 标准。

若有序，按 `<` 对成员排列；

```c++

```

若无序，需定义成员的哈希函数。

```

```

## multi set / map

## unordered set / map

# 内存管理

动态内存，又称为堆（heap）。

C 语言中，`stdlib.h` 。

# 断言

断言，Assert，在程序插入断言，只有断言内的表达式为真，程序才能继续运行，。通常断言只在调试模式中有效，会令调试版本的运行速度慢于发布版本。

# 异常

异常，exception，用于标志程序发生错误或意外。例如系统不能响应 `new` 的内存请求（如没有多余的内存），则将抛出一个异常。

由于异常会带来很大的系统开销，所以仅适用于致命错误（如读取磁盘错误），不适用于广泛的普通错误检查（如输入无效数据）。

异常使用三个关键字 `try` 、`throw` 、`catch`：

* `try` —— **尝试**运行某代码。
* `throw` —— 代码出错**抛出**异常。
* `catch` —— **捕获**某异常并处理该异常。

> 异常应用实例：
>
> ```c++
> 
> ```
>
> 

# 输入输出

流（stream）的概念：

输入源自键盘输入或文件；输出到达打印显示或文件。

C 语言中，输入输出功能由 [\<stdio.h>](http://www.cplusplus.com/reference/cstdio/) 提供。



stream ，流，概念上，。



C++ 标准库提供的输入输出流头文件：

* `<iostream>` 
* `<fstream>`
* `<sstream>`

流没有赋值操作。

## 标准输入终端输出



## 文件输入文件输出

C 使用 [<stdio.h>]() 头文件。

> C，文件的打开与关闭。C99用 `fopen` 打开。C11引入 `fopen_s` 以安全模式打开。
>
> ```C
> // 传入文件名（带绝对或相对路径）、打开模式，打开文件。将打开的文件指针赋值给FILE*型变量。
> FILE *windowsTextFilePtr = fopen("C:\\Users\\Me\\Desktop\\text.txt", "r");
> FILE *unixBinaryFilePtr = fopen("/text.bin", "rb");
> 
> // 对文件操作完成后，关闭文件
> fclose(windowsTextFilePtr);
> fclose(unixBinaryFilePtr);
> ```

> C，读取窄字节字符的数据
>
> ```C
> // 函数名c表示charater
> ```

> C，将窄字节字符串写入文件
>
> ```c
> FILE *filePtr = fopen("ASCIIText.txt", "w+"); 
> fputs("This is some put text\n", filePtr); // 往文件写入数据，函数名s表示string
> fclose(filePtr); // 关闭文件
> ```

> C，将宽字节文本数据写入文件
>
> ```c++
> FILE *filePtr = fopen("ASCIIText.txt", "w+"); 
> ```

> C，读取二进制文件的所有数据

> ```C
> // 假设 doubleData.bin 是连续存放了5个double型浮点数的文件
> FILE *filePtr = fopen("doubleData.bin", "rb");
> fseek( filePtr, 0L, SEEK_END); // 定位到文件末尾
> // double型占8字节，文件共占是40字节
> 
> ```

> C，将二进制数据写入文件
>
> ```C
> FILE *filePtr = NULL; // 定义文件指针
> 
> ```
> 

> 

C++ 使用 `<iostream>` 头文件。

> C++，文件的打开与关闭。
>
> ```c++
> 
> ```
>
> 





## 格式化流

## 错误输出

## 日志输出

# 编译流程



编译单元，，是编译阶段。

## 预处理

宏定义

**条件编译。**

**单次编译。** 预处理 once pragma 可以使此文件下的代码只编译一次。

------

**字节对齐编译。** 预处理 [pack pragma](https://docs.microsoft.com/en-us/cpp/preprocessor/pack?view=vs-2019) 可以设置结构体、类、联合体。

> 默认 4 字节对齐：
>
> ```c++
> sizeof(long long);	// 8 Bytes
> sizeof(int);		// 4 Bytes
> sizeof(char);		// 1 Byte
> struct S
> {
>     long long ll;	// 8 Bytes
>     int i1;			// 4 Bytes
>     char c;			// 4 Bytes		
>     int i2;			// 4 Bytes
> }
> sizeof(S);			// 24 Bytes
> ```
>
> 预处理设置 1 字节对齐：
>
> ```c++
> sizeof(long long);	// 8 Bytes
> sizeof(int);		// 4 Bytes
> sizeof(char);		// 1 Byte
> #pragma pack(1)
> struct S
> {
>     long long ll;	// 8 Bytes
>     int i1;			// 4 Bytes
>     char c;			// 4 Bytes		
>     int i2;			// 4 Bytes
> }
> sizeof(S);			// 24 Bytes
> ```

------

## 编译

## 汇编

## 链接

# 调试

# 时间

# STL 算法

> 参考
>
> [Youtube - 一小时内学习105种STL算法](https://www.youtube.com/watch?v=bFSnXNIsK4A)

## 排序 `sort `

[sort](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#sort) ，两种函数重载，可缺省使用 `<` 运算符作排序的比较；或传入比较函数变量，依据此函数排序。

1. 默认使用 `<` 运算符进行排序

```c++
std::vector<int> v1 = {8, 10, 15, 23, 55, 22, 78, 11, 28};
std::sort(v1.begin(), v1.end()); // 8 10 11 15 22 23 28 55 78
```

对于自定义类型，必须定义类型的 `<` 运算符。对于容器成员，若 `a < b == false && b < a == false` ，则 `a == b` 。

```c++
struct Box
{
    double length;
    double width;
    double height;
    double volume;
    Box(double l, double w, double h) : length(l), width(w), height(h)
    {
        volume = l * w * h;
    }
    bool operator<(const Box &other) const { return volume < (other.volume); }
};

std::vector<Box> SomeBoxes;
Box box1(5, 7, 8);
Box box2(1, 3, 5);
Box box3(7, 7, 7);
Box box4(10, 14, 16);
Box box5(3, 3, 3);
SomeBoxes.push_back(box1);
SomeBoxes.push_back(box2);
SomeBoxes.push_back(box3);
SomeBoxes.push_back(box4);
SomeBoxes.push_back(box5);

// SomeBoxes's volume sequence before sorted: 280 15 343 2240 27

std::sort(SomeBoxes.begin(), SomeBoxes.end());

// SomeBoxes's volume sequence after sorted: 15 27 280 343 2240
return 0;
```

2. 使用自定义比较函数进行排序

```c++
bool GreaterInt(int integer1, int integer2)
{
    return integer1 > integer2;
}
```

```c++
std::vector<int> v1 = {8, 10, 15, 23, 55, 22, 78, 11, 28};
std::sort(v1.begin(), v1.end(), GreaterInt); // 78 55 28 23 22 15 11 10 8
```

 [is_sorted](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted)

 [is_sorted_until](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted_until)

# 数学

## 常用数学函数

## 虚随机数

## 复数

# 并行

C++11新特性。C++11标准库只定义了标准的线程管理，没有定义标准的进程管理。这使进程间的通讯依赖于平台操作系统的API。若为了更好移植性，应选择多线程而不是多进程。

> C++ 11 - 线程版 Hello World 程序
>
> ```c++
> #include <thread> // 声明了管理线程的函数和类的标准C++11头文件
> #include <iostream>
> void hello() // 作为线程的初始函数，被创建的线程从此函数开始运行
> {
>     std::cout << "Hello World" << std::endl;
> }
> int main() // 应用程序的初始线程从main函数开始运行
> {
>     std::thread t(Hello); // 在初始线程内创建一个标准线程类的对象，使用hello初始化，并启动
>     t.join(); // 只有子线程结束后主线程才可以结束，否则初始线程自顾继续运行，可能先于新线程结束。
>     return 0; 
> }
> ```

每个程序至少有一个线程执行main函数，其余线程则有各自的入口函数。











































## ~~Statement 语句~~

### ~~Selection (Branch) 选择（分支）~~

### ~~Iteration (Loop) 迭代（循环）~~

## ~~Pointer 指针~~



### ~~`void` pointer~~

### ~~`NULL` pointer~~

### ~~pointer to pointer~~

## ~~Function 函数~~

### ~~Argument List  参数表~~



> ~~**拓展**：C 标准库头文件 `<stdarg.h>` 或 C++ 标准库头文件 `<initializer_list>` 可用于实现**参数个数可变**。~~

### ~~overload 重载~~



### ~~inline 内联~~

### ~~Pointer to Function 函数指针~~

### ~~Callback Function 回调函数~~

~~通过函数指针~~

## ~~Lambda (Closure) 闭包~~

~~lambda 就是一种匿名函数，没有函数名的某种，又称为 closure，闭包。~~

## ~~Enumeration 枚举~~

~~枚举用于定义只有几种有限可能的类型。~~

 ```c++
enum Suit // Suit is Enumeration
{
    // heart etc. is Enumerator
    heart,   /*♥️*/ 
    spade,   /*♠️*/
    club,    /*♣️*/
    diamond  /*♦️*/
}

void checkSuit(Suit suit)
{
    // Enumeration always match with switch brach.
    switch (suit)
    {
        case heart:
            /**/
            break;
            
            
            
    }
}
 ```

## ~~Union 联合~~

~~Union 联合，继承自 C 语言。~~

## ~~Class & Struct 类 & 结构~~

### ~~Define Class/Struct 定义类/结构~~



~~在 C 中，定义一个结构实例需写 `struct TypeName instanceName` ；在 C++ 中，可省略 `struct` 关键字写 `TypeName instanceName` 。~~

### ~~member 成员~~

### ~~member function 成员函数~~



#### ~~`this` 指针~~

~~`this` 指针指向~~ 

### ~~Constructor & Initialization 构造函数 & 初始化~~

~~构造函数用于~~

```c++

```

#### ~~初始化列表~~

```c++
{
    
}
```

### ~~Static 静态~~ 

## ~~Operator Overloading 运算符重载~~

~~设计运算符重载是，应遵循逻辑。语法如下：~~

```c++
type operator operator-symbol ( parameter-list )
```

### ~~Unary 一元运算符~~

~~可被重载的一元运算符： `!` ` &` ` ~` ` *` ` +` ` -` ` ++`  `--` 。~~

### ~~Binary 二元运算符~~

```c++
struct Box
{
    unsigned int length;
    unsigned int height;
    unsigned int width;
};

bool operator<(const Box &lhs, const Box &rhs)
{
    return (lhs.length * lhs.height * lhs.width) < (rhs.length * rhs.height * rhs.width);
}

bool operator>(const Box &lhs, const Box &rhs)
{
    return (lhs.length * lhs.height * lhs.width) > (rhs.length * rhs.height * rhs.width);
}

int main()
{
    Box myBox, yourBox;
    myBox.length = 2;
    myBox.height = 2;
    myBox.width = 2;
    yourBox.length = 1;
    yourBox.height = 1;
    yourBox.width = 1;

    myBox < yourBox; // false
    myBox > yourBox; // true

    return 0;
}
```

## ~~Exception 异常~~

## ~~Assertion & Debug 断言与调试~~

~~在 C++ 程序的三个生命周期：预处理（preprocessing）、编译（compile）、运行时（runtime），分别有以下。~~

* 
* 

~~`Assert(oughtToBeTrueExpression)` 是一个宏定义，~~

## ~~Preprocessor 预处理~~

~~[C/C++ 预处理](https://docs.microsoft.com/en-us/cpp/preprocessor/c-cpp-preprocessor-reference)~~ 

### ~~条件编译~~

## ~~Compile 编译~~

~~编译器将 `.cpp` 和 `.h` 的 C++ 文本代码历经4个步骤： Preprocessing 预处理 →  Compilation → Assemble → Linking 链接，生成可执行文件（Executable File）或库（Library）。~~

### ~~Environment 环境~~

#### ~~GCC~~

~~[GCC](https://gcc.gnu.org/)，下载 。Windows 通过 MinGW 安装；macOS 通过 Homebrew 安装。~~

1. ~~下载MinGW：[官网地址](http://www.mingw.org/)~~
2. ~~安装MinGW：[默认位置](file:///C:/MinGW)~~
3. ~~修改环境变量：~~
   1. ~~计算机—属性---高级系统设置---环境变量，~~
   2. ~~在系统变量中找到 Path 变量，~~
   3. ~~在后面加入 min-gw的安装目录，如 [C:\MinGw\bin](file:///C:/MinGw/bin)~~
4. ~~验证：如果在cmd输入“mingw-get”能弹出MinGw     sinstallation manager 窗口，则安装成功~~
5. ~~安装gcc：cmd中输入“mingw-get install     gcc”，gcc用于编译.c文件~~
6. ~~安装g++：cmd中输入“mingw-get install g++”，g++用于编译.cpp文件~~
7. ~~安装gdb：cmd中输入“mingw-get install gdb”，gdb用于编译时调试~~
8. ~~编译.c文件：cmd中输入“gcc XXX.c”，将当前文件夹下XXX.c编译成a.exe文件~~
9. ~~调试程序：cmd中输入“gdb a.exe”，就可以是用gdb常用的命令进行调试程序了~~
10. ~~更新MinGW：cmd中输入“mingw-get update”,cmd中输入“mingw-get upgrade”~~

> ~~备注~~
>
> * ~~如果出现 Windows 平台下控制台乱码，则前往 `MinGW\share\locale` ，删除中文环境。~~

#### ~~Clang & LLVM~~

1. ~~下载LLVM：[官网地址](http://releases.llvm.org/download.html)，选择Pre-Built     Binaries中的Clang for Windows (64-bit)，获得exe文件~~
2. ~~运行exe文件，勾选Add LLVM to the     system PATH for all users（即第二项）。[默认位置](file:///C:/Program Files/LLVM)~~
3. ~~验证：cmd中输入“clang -v”，显示clang版本，则安装成功~~
4. ~~编译.c文件：cmd中输入“clang XXX.c”，将当前文件夹下XXX.c编译成a.exe文件~~

#### ~~Microsoft Visual C++~~

#### ~~Apple Xcode~~

~~Xcode IED 使用 LLVM 编译 C 家族语言。~~

### ~~Multiple Files Project 多文件工程~~

# ~~Standard Library 标准库~~

> ~~**参考**~~
>
> ~~[Microsoft Docs - C++ Standard Library](https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-reference)~~ 
>
> ~~[Microsoft Docs - C++ standard library header files](https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-header-files)~~

~~C++ Standard Library ，C++ 标准库。命名空间位于 `namespace std` 。~~





### ~~\<string\> 字符串模板类~~

~~头文件 [\<string\>](https://docs.microsoft.com/en-us/cpp/standard-library/string) 。~~

```c++
std::string myName = "";
```



# ~~I/O Stream 输入输出流~~

~~stream，流，具有输入/输出功能。stream 对象是一串有方向的字节包裹，具有 source 源头、destination 目的地。文件、控制台、字符串变量的读/写，会对 stream 对象进行操作。~~

## ~~string stream 字符串流~~

```

```

## ~~file stream 文件流~~

~~头文件 \<fstream\>  。 `class ifstream` 支持将 stream 输入/输出到文件，~~

# ~~Iterators 迭代器~~

~~[Iterators](https://docs.microsoft.com/en-us/cpp/standard-library/iterators)，迭代器，~~



## ~~Algorithms 算法~~

~~Algorithms ，算法，由 100+ 个函数组成。泛型编程使算法函数可应用于多种数据结构。头文件 [\<algorithm\>](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm) 。~~



### ~~copy 复制~~

### ~~find 寻找~~

### ~~fill 填充~~

### ~~replace 替换~~

### ~~Lexicographical 字典序~~

~~字典排序规则：从首位比较，若相等，则比较下一位。~~

### ~~permutation 全排列~~

~~[next_permutation](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#next_permutation) 与 [prev_permutation](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#prev_permutation) 可用于获取上一个/下一个全排列。以 {A,B,C} 为例理解 next 与 previous 的含义：按字符 A<B<C 为小到大顺序的三者，排列数有 $A_3^3=\frac{3!}{(3-3)!}=6$ 种。这 6 种小到大排序为：ABC<ABC<BAC<BCA<CAB<CBA，这种排序称为**字典排序（lexicographical order）** 。~~

~~参数 first iteration、last iteration 指明在此 iterator 之间计算上/下个全排列，必须是顺序类型的 iterator。`bool` 型返回值，`true` 表示还有下一个全排列，`false` 表示已经没有下一个。 若缺省了比较函数，则默认使用 `<` 运算符比较，否则需传入比较函数。~~

```c++
std::string strABC = "ABC";
do{
    std::cout << strABC << " ";        
}while(std::next_permutation(strABC.begin(), strABC.end()));
// output: ABC ACB BAC BCA CAB CBA
```

## ~~memory management 内存管理~~ 

### ~~Smart Pointer 智能指针~~

## ~~Time 时间~~

~~头文件 [\<ctime\>](https://docs.microsoft.com/en-us/cpp/standard-library/ctime) 源于 C 标准库 time.h；头文件 [\<chrono\>](https://docs.microsoft.com/en-us/cpp/standard-library/chrono) 属于 C++ 标准库。~~

### ~~ctime~~

```

```



### ~~chrono~~
