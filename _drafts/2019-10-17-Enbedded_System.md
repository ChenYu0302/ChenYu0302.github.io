# 实时操作系统 RTOS

## 介绍

实时操作系统（Real-Time Operating System，RTOS）是一个旨在当实时应用程序处理数据时，通常没有缓冲延迟的操作系统。一个RTOS的价值体现在它的响应速度或可预测程度，而不在于它在给定时间段内可以执行的工作量。RTOS 的特性使其适合运行于各种嵌入式设备，在实现复杂功能与体型轻巧上取得了很好的平衡。一个RTOS具有以下的特点：

| 特点       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 延迟小     | 为了达到“实时性”，RTOS 必须具有很小的延迟。                  |
| 确定性     | 开发应用程序时，必须明确处理过程所需的时长，才能确保在最后期限前完成任务。 |
| 模块化     | 以模块的方式分而治之，只需简单地将已有模块添加到应用程序。在本项目中，将大量使用芯片厂商SDK中提供的已有模块实现快速开发。 |
| 可伸缩性   | 开发人员可以从简单的应用程序扩展到具有协议栈，驱动程序，文件系统等的复杂应用程序。 |
| 低负担开发 | RTOS 管理着系统的许多方面，这使得开发人员仅专注于他们的应用程序。例如，RTOS会通过调度程序，自行管理电源、中断表、内存，异常处理等。 |

## 术语

### 标准类型的线程

线程（Thread）是任何执行块的通用术语，具体分类如下：

| 线程类型                                        | 描述                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| 中断服务程序 （Interrupt Service Routine，ISR） | 由硬件中断启动的线程。一个ISR 运行后立即结束。所有的ISR都共享相同的堆栈。 |
| 任务 （Tasks）                                  | 通常，任务是可以长期存在的线程。每个任务都有自己的堆栈，这使得它可以长期存在。如果任务正在等待资源而不占用任何CPU，则操作系统会阻塞该任务。 |
| 空闲 （Idle）                                   | 最低优先级线程，仅在没有其他线程准备好执行时才运行。通常，空闲只是一项具有最低优先级的特殊任务。 |

### 调度程序

每个 RTOS 都有一个调度程序（Scheduler）。调度程序负责对系统中线程的执行进行管理。包括了以下两种：

| 线程类型                             | 描述                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 抢占式调度 （Preemptive Scheduling） | 抢占式调度是最常见的一种 RTOS 调度器类型，当前正在运行的线程将一直持续运行，直至出现下面的其中一种情况： 该线程运行完毕（例如 ISR 运行完毕）； 优先级较高的线程就绪，这时，优先级较高的线程将抢占优先级较低的线程，故名“抢占式调度”； 线程由于正在等待资源而放弃处理程序（例如任务调用 sleep() 函数）。 |
| 时间片调度 （Time-slice Scheduling） | 这种类型的调度保证每个线程都有被给予一个槽以便执行，但通常不利于实时应用程序。 |

### 线程安全

如果一段代码可以保证以多个线程同时正确访问（读/写）的方式操作共享数据结构，则称这段代码是线程安全（Thread-safe）的。线程安全不仅仅在 RTOS 任务上需要注意，例如，中断对同一内存修改时也必须小心。

### 阻塞

如果任务正在等待资源而不占用任何CPU，则该任务被阻塞（Blocked）。

## 裸机程序 VS RTOS

典型的裸机（Bare-Metal）应用程序通常可以分为三个关键部分：

- 初始化：main 函数中第一部分，实现初始化硬件和软件组件；
- 超级循环状态机：main 函数中第第二部分，：在 while(1) {...} 循环中确定系统状态转移方式，以实现应用程序的功能。应用程序基于轮询结果，或基于中断的执行结果（例如，接收到SPI数据包或计时器到期），作出对应的行为。
- ISR：由外设（例如UART），定时器或其他特定于设备的项目（例如异常或多核通信）的中断执行的代码。

裸机程序存在的意义在于小巧，快速，应用程序相对简单容易理解。一旦需要更复杂的逻辑，RTOS 将大放异彩。功能上讲，最小 RTOS 与裸机程序的三大部分有如下的对应关系：

- 初始化：main 函数中第一部分代码完成初始化硬件和软件组件后，启动 RTOS 内核；
- 空闲循环：空闲线程是优先级最低的线程，实现状态转移的循环。
- ISR：与裸机程序一样，为中断执行的代码。

虽然裸机应用程序和最小 RTOS 应用程序之间这三部分基本相同，但是对最小 RTOS 添加任务，可以获得更为复杂的应用程序，同时允许多个开发人员添加其内容，而无需处理裸机程序中脆弱的超级循环。



## RTOS 组件

一个 RTOS 的组件构成包括：

- 调度程序：抢占式调度程序保证正在运行的事最高优先级的线程；
- 通信机制：信号量（Semaphores），消息队列（Message Queues），队列（Queues）等；
- 严格的区域机制：互斥（Mutexes），门（Gates），锁（Locks）等；
- 计时服务：时钟，计时器等；
- 电源管理：对于低功耗设备，电源管理通常是 RTOS 的一部分，因为它知道设备的状态；
- 内存管理：可变大小的堆，固定大小的堆等；
- 外设驱动器：UART，SPI，I2C等；
- 协议栈：BLE，WiFi 等协议栈；
- 文件系统：FatFs 等；
- 设备管理：异常处理，启动引导等。

## POSIX

POSIX 是用于操作系统兼容性的 IEEE 行业 API 标准，POSIX API 是在底层 RTOS 之上的一个小垫片，作为操作系统的兼容层，这使得允许应用程序在操作系统之间轻松移植。当创建一个 POSIX Pthread 时，会创建一个底层 RTOS 任务。类似地，当创建一个 POSIX Pthread 信号量时，会创建一个底层 RTOS 信号量。对于一个支持POSIX的操作系统，一个很好的优势在于能够从网络上获取基于POSIX 的代码并很快使其工作。



## 线程通讯

为了实现线程间的通讯，RTOS 提供了标准的通信机制，如信号量，互斥，消息队列，链接列表等。

### 信号量（Semaphore）

信号量允许资源管理。任务可以被`sem_wait()`阻塞，直到资源可用并且一个`sem_post()`调用完成。一个常见的用例是外设中断接收数据并发布信号量，以便任务可以处理它。这是设计者所希望的，因为它最小化了中断的持续时间。

```
void myHwi() { // 我的硬件中断
    // 从外设获取数据
    Semaphore_post(handle);
    // 完成
}
void myTask() { // 我的任务线程
    // ...
    while(cond) {
        Semaphore_pend(handle, timeout);
        // 处理数据
    }
    // ...
}
void barTask() {
    MyMsg msg;
    // ...
    while(cond) {
        // fill in msg
        Mailbox_post(handle, &msg);
    }
}
void fooTask() {
    MyMsg msg;
    // ...
    while(cond) {
        Mailbox_pend(handle, &msg);
        // Process info in msg
    }
    // ...
}
```

所有上述的线程切换都由RTOS中的调度程序管理。

1. 一旦内核的调度程序启动（本例中`BIOS_start()`位于`main()`中），所有任务都准备好运行，但它是首先运行的任务是`高`，因为它具有最高优先级并且可以被运行。
2. `中断服务程序`被调用，因此它优先于所有任务。高位现在处于先发制人状态。
3. 一旦中断服务完成，`高`开始再次运行，直到它因`Task_sleep()`被阻塞（或某些阻塞API）。现在`中A`可以运行了。
4. `中A`一直运行直到遇到阻塞调用（比方说`Semaphore_pend()`）。现在`中B`可以运行了。
5. `中B`运行直到`高`被停止阻塞（比如`Task_sleep()`已过期）。`中B`现在被抢占。
6. `高`运行直到`中断服务程序`被调用并且抢占`高`。注意：现在有两个任务被抢占了。
7. `中A`准备就绪（比如`中断服务程序`发布了被阻止的信号量）。由于存在更高优先级的线程，`中A`无法运行。
8. `中断服务程序`完成，因此`高`再次运行然后再次阻塞，因此`中B`再次运行直到它阻塞。现在`中A`可以运行，因为没有更高优先级的任务在运行。注意：`中A`必须等到`中B`完成，因为在`中A`准备就绪后`中B`正在运行。
9. `中A`阻塞，现在没有线程正在运行或准备运行，所以`空闲`终于运行，直到...
10. `中B`解锁并运行。

上图可描述为：



执行图如下：

- 中断服务程序（ISRX）
- 中A：首先在`main()`中创建，优先级为4
- 中B：第二在`main()`中创建，优先级为4
- 高：最后在`main()`中创建，优先级为8

在一个抢占式调度程序中，假设在`main()`中创建了以下线程：

### 线程执行（Thread Execution）

请注意POSIX支持层中的消息队列构建在 TI-RTOS 中的`Mailboxes`和 SimpleLink SDK 中的 FreeRTOS 中的`Queues`之上。 	 

当你希望将特定功能集中到单个任务中时，消息队列非常有用。所有其他线程可以将消息发送到集中任务以进行处理。消息队列以线程安全的方式处理消息。

消息队列对于在线程之间发送数据很有用。消息队列可以配置为发送/接收任何大小的用户定义消息。这里的例子为任务向另一个任务发送消息。

### 消息队列（Message Queue）

大多数RTOS都支持二进制和计数信号量。