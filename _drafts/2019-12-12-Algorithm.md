---
layout: post
title:  算法
date:   2019-12-03 00:55:30 +0800
categories: 计算机科学
---

# 数据结构与算法

> 参考
>
> *算法图解 ISBN*，漫画形式入门科普算法。
>
> 清华大学邓俊辉数据结构[公开课](https://www.bilibili.com/video/av49361421)、教材。
>
> [Data Structures Easy to Advanced Course](https://www.youtube.com/watch?v=RBSGKlAvoiM)，谷歌工程师8小时数据结构教程。

数据结构，data structure，DS，组织某些数据使其可以更高效地使用（如访问，更新等）。

算法，algorithm，是一组完成任务的指令，任何代码片段都可视为算法，在编程时采用更好的算法可以有更少的时间和空间的开销。



## 大——衡量复杂度

当有100个元素时，简单查找法为二分查找速度为简单查找的15倍；当有10亿个元素时，简单查找法为二分查找速度为简单查找的3300万倍。可见随着元素增加，二者的运算次数增加速度不同。

大O表示法表明了算法运行时间的增速，而不是具体的运行时间。可用于比较操作次数随操作对象数的增长情况。

简单查找法的运行时间为记为O(*n*)，二分查找法的运行时间记为O(log *n*)。

几种常见的大O运行时间（由快至慢）：

| 大O表示法        |          | 实例                     |
| ---------------- | -------- | ------------------------ |
| $O(1)$           | 常数时间 | 读取数组的任何位置的元素 |
| $O(log_n)$       | 对数时间 | 二分查找                 |
| O(*n*)           | 线性时间 | 简单查找                 |
| O(*n* * log *n*) |          | 快速排序                 |
| $O(n^2)$         |          | 选择排序                 |
| $O(n!)$          | 阶乘时间 | 旅行商问题解法           |

## 二分查找
**规则**：我随便想一个1~100的数字。你的目标是以最少的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。

**猜法 1**：从1开始依次往上猜，称为简单查找。每次猜测都只能排除一个数字。如果数字是99，猜99次才能猜到。<br>
**猜法 2**：从 50 开始，如果小了，则排除了一半的数字。接下来，你猜75，又排除了一半……称为二分查找。每次猜测的是中间的数字，从而每次都将余下的数字排除一半 。$2^7 = 128 > 100$，所以最多7次就可以猜到。

类似的，查找一本字典里某个单词的位置，网站在数据库检索用户名的位置，都可以使用**二分查找法（Binary Search）**。

**代码：二分查找法**：

```swift
func binarySearch(list:[Int], item:Int) -> Int? {
    // low和high用于跟踪要在其中查找的列表部分
    var low = 0
    var high = list.count - 1
    
    while (low <= high) { // 只要范围没有缩小到只包含一个元素,
        // 就检查中间的元素
        let mid = (low + high) / 2
        let guess = list[mid]
        if (guess == item) {
            return mid // 找到了元素
        }
        if (guess > item) {
            high = mid - 1 // 猜的数字大了
        } else {
            low = mid + 1 // 猜的数字小了
        }
    }
    return nil // 没有指定的元素
}

let myList =  [1, 3, 5, 7, 9]
print(binarySearch(myList, 3)) // 1
print(binarySearch(myList, -1)) // nil
```

**总结**：对于包含n个元素的列表，用二分查找最多需要 $log_2n$ 步，而简单查找最多需要 $n$ 步。涉及到算法时，都将讨论其运行时间。一般而言，应选择效率最高的算法，以最大限度地减少运行时间或占用空间。 对于简单查找法，最多需要猜测的次数与列表长度相同 ，称为**线性时间**（Linear Time）。对于二分查找法，最多需要猜测的次数与列表长度的对数相同，称为**对数时间**或**log时间**。

## 旅行商问题

**问题**：要前往n个城市，同时要确保旅程最短。需可考虑
前往这些城市的各种可能顺序。

**结果**：需要执行*n*!次操作，若涉及的城市数很多，则需要执行非常多的操作。

## 内存的工作原理

计算机的 RAM ，random access memory，随机访问存储器，就像是很多抽屉的集合体，每个抽屉都有地址。比如`fe0ffeeb`是一个内存单元的地址，可对该地址读写。<br>
需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。
<br>需要存储多项数据时，有两种基本方式——数组和链表。

## 数组与链表
### 数组
所有元素在内存中都是相连的。<br>
* 插入元素很困难。若没有足够的空间，需将整个数组复制到其他地方。O(*n*)
* 删除元素很困难，后面的元素都要前移。O(*n*)。
* 随机读取元素很简单，可迅速找到数组中任何位置的元素。O(1)
### 链表
元素储存在内存中任何位置，每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。<br>
* 插入元素很简单，只需修改它前面的那个元素指向的地址。O(1)
* 删除首尾元素很简单，因为通常记录了链表的第一个元素和最后一个元素。O(1)
* 随机读取元素很困难，需从头按顺序逐个访问。O(*n*)

## 选择排序

**问题**：对大小随机的元素排序。

**结果**：第1次遍历所有n个元素找到最大的元素，第2次遍历所有n-1个元素找到最大的元素...第n-1次遍历所有2个元素找到最大的元素，第n次遍历所有1个元素找到最大的元素。总计 n(n+1)/2 次。记为O(*n*<sup>2⁡</sup>)。

**代码**：
```swift
func findSmallest(array:[Comparable]) -> Comparable {
    
}

func selectionSort(array:[Comparable]) -> [Comparable] {
    
}

print(selectionSort(array:[5,3,6,2,10])) // 2,3,5,6,10
```

## 栈

## 递归
