---
layout: blog
title: C++
permalink: /blog/Cpp.html
date: 2020-02-14 01:06:00 +0800
category: 开发
tags: 
---

> **参见**
>
> *Stanley B Lippman - C++ Primer 5th Edition*，C++ 11 权威学习书籍。
>
> [C++ Reference](https://en.cppreference.com/)，[C++ 参考手册](https://zh.cppreference.com/)，查阅 C/C++ 编程语言与标准库。
>
> [Microsoft Docs](https://docs.microsoft.com/) - [C++ Language Reference](https://docs.microsoft.com/en-us/cpp/cpp/cpp-language-reference), [Standard Library Reference](https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-reference)，微软的 C++ 语言与标准库参考。
>
> [Standard C++](https://isocpp.org/) ，标准 C++ 官方网站。

[TOC]

# 知识体系

C++ 标准库由三部分组成：

1. C 语言标准库
2. 

# 工作原理

编译 - 链接 - 运行。

# 现代C++新特性

C++98 在广泛使用很长事件后，C++11 。

# 词法公约

标准的C++代码的基本字符包括：大小写英文字母、数字、`_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '` 标点符号。

C++ 代码由令牌（Token）和间隔构成。令牌是代码里的最小有意义单位。

编译时，语法分析器识别的令牌归为：[关键字][]，[标识符][]，[字面值][]，[运算符][]，标点符号 。

令牌被之间有间隔，可以是空格、制表符、换行符、换页符、注释。

## 关键字

[关键字]: 关键字	"Keyword"

C：

* 类型相关：`bool` `char` `int` `double` `float` 
* 控制相关：`if  ` `switch` `` `for` `do` `while` 

C++新增：



## 标识符
[标识符]:#标识符
标识符，identifier，用于给类型、变量、函数的命名。规则：

* 

## 字面值

[字面值]:#字面值

Literal，字面值，直接用字符描述的数据常量，常被用于给变量赋值。

> 整数字面值：默认是 `int` 型十进制。加入前缀表示为类型或其他进制。
>
> ```c++
> 10;		// 十进制10 
> 0x10;	// 十六进制10 ，等于十进制16
> 0b10;	// 二进制10 ，等于十进制2
> -10		// 带有负号运算符的字面值10，因为严格意义上字面值不会是负数。
> ```

> 小数字面值：。默认是 `double` 型。
>
> ```c++
> 
> ```

> 文本字面值：' ' 内为字符；" " 内为字符串。
>
> ```C++
> 
> ```

> 指针字面值，只有C++空指针 `nullptr` 一种。

# 基本类型

内置类型，Build-In Types，不依赖头文件，编译器自动支持。

## 无类型

void 

## 整型

整型，integral，用于表示整数。

存储原理：对于占 n 个 bit 的存储整数型：若没有 `unsigned` 修饰，则首位作为正负标志位，1表示负数，0表示正数，后面的位表示绝对值大小，范围是 $-2^{n-1}$ ~ $2^{n-1}-1$；若有 `unsigned` 修饰，所有位都用于表示大小，范围是 $0$ ~ $2^n-1$。

|         类型         | 描述                    |    占用    |             取值范围             |
| :------------------: | ----------------------- | :--------: | :------------------------------: |
|        `bool`        | 0为 false，非0为 true。 |   1 Byte   |        `true` 或 `false`         |
|        `char`        |                         |   1 Byte   |            -128 ~ 127            |
|   `unsigned char`    |                         |   1 Byte   |              0~256               |
|        `int`         |                         |  机器位长  | -2147483648 ~ 2147483647 (32bit) |
|    `unsigned int`    |                         |  机器位长  |     0 ~ 4,294,967,295(32bit)     |
|       `short`        |                         | \>= 2 Byte |                                  |
|   `unsigned short`   |                         | \>= 2 Byte |                                  |
|        `long`        |                         | \>= 4 Byte |                                  |
|   `unsigned long`    |                         | \>= 4 Byte |                                  |
|     `long long`      |                         | \>= 8 Byte |                                  |
| `unsigned long long` |                         | \>= 8 Byte |                                  |

由于 `short` 和 `long` 在 C 语言只要求了最小长度，若对长度有具体要求（有更好的可移植性），则使用 `uint_16` 等类型。

## 浮点型

浮点型，floating point。存储原理：

# 变量说明符

# 命名空间

# const 常量修饰符

1. 用于修饰一经创建就不可修改的常量。用`const` 修饰的常量，相比 `#define` 宏定义的文本替换，具有类型检查的优点。

```c++
const double PI = 3.141592653;
```

2. 用于修饰

> `const char*`,  `char const*`, `char* const` 的区别
>
> 

左值与右值。

# typedef 定义类型别名

用来给已有的类型去一个新名字，可以避免直接使用原类型名，令表述更简洁。

```c++
typedef std::map<std::string, unsigned int> NameToAgeMap;
```

# auto 

# 指针/引用

[指针]:#指针



引用，Reference，是 C++ 语法做的优化。本质上，在编译后**还是靠指针**来实现的。对引用操作相当于对其本身操作。

> ```c++
>int myAge = 23;
> int *ptrMyAge; 		// '*' 用于声明变量是指针类型
> ptrMyAge = &myAge; 	// '&' 用于获取变量的地址
> *ptrMyAge = 24;		// '*' 用于获取指针指向的对象
> ```

# 字符与字符串

在 C 语言中，字符串就是以 `\n` 结束的字符数组。 

`"String Content"` 字面值 。

C 标准库。`string` 。

C++ 标准库。`std::string` 。

# 集合类型

同种类型的多个对象构成的对象。

## 数组

数组，array。数组成员在内存上连续分布，常常配合指针的偏移访问数组成员。

## 标准模板库容器

标准模板库容器，Standard Template Library Container，STL Container ，是用于管理和组织其他对象的对象，基于模板实现。包括两种：

1. 顺序容器，Sequence Containers ，根据**位置**管理元素。包括 vector。
2. 关联容器，Associative Containers，根据**键（Key）**管理元素。包括 set、map。

### vector

头文件 [\<vector\>](https://docs.microsoft.com/en-us/cpp/standard-library/vector) 。可变大小，可任意位置增删成员，综合性能最好。

工作原理：。

> 初始化
>
> ```c++
>  // 定义空容器
> std::vector<int> v1;
>  // C++ 11 new: 初始化并赋值
> std::vector<int> v1 = {1,2,3,4,5};
> // 用迭代器初始化
> std::set<int> s1 = {9, 8, 7, 6, 5, 4, 3};   // 3 4 5 6 7 8 9
> std::vector<int> v1(s1.begin(), s1.end());  // 3 4 5 6 7 8 9
> 
> ```
>
> 更新
>
> ```
> 
> ```
>
> 

### array

### set

关联容器共计8种类型，从3个维度区分：

* 是可通过 key 访问 value 的 `map` 还是 value 就是 key 本身的 `set` 。
* `multi`前缀表示 key 能否重复。
* `unordered`前缀表示成员是否有序。

头文件 [\<set\>](https://docs.microsoft.com/en-us/cpp/standard-library/set)  \<[map](https://docs.microsoft.com/en-us/cpp/standard-library/map)\>  \<[unordered_set](https://docs.microsoft.com/en-us/cpp/standard-library/unordered-set)\>  \<[unordered_map](https://docs.microsoft.com/en-us/cpp/standard-library/unordered-map)\> 

iterator 是 const 的：这意味着不能用诸如 `std::copy` 等算法他们操作。

严格若序的，

`std::set` 存储已排序对象，默认对 Key 依据 `<` 运算符排序。

```c++
// 定义一个 set 对象

std::vector<int> v1 = {9, 9, 8, 8, 8, 7, 7, 6, 5, 4, 3, 3}; // 原数据成员无序且存在重复成员
std::set<int> s1(v1.begin(), v1.end());		// 会自动排序 {9, 8, 7, 6, 5, 4, 3}

// 定义一个 map 对象
set::map<pair<std::string, int>> 
```

若成员是自定义类型 ，必须对 Key 重载`<`运算符。因为成员严格，若有 `a < b == false && b < a == false` ，则 `a == b` 。所以通过重载 `<` 运算符实现唯一性。

```c++
struct Box
{
    double length;
    double width;
    double height;
    double volume;
    Box(double l, double w, double h) : length(l), width(w), height(h)
    {
        volume = l * w * h;
    }
    bool operator<(const Box &other) const { return volume < (other.volume); }
};

std::set<Box> SomeBoxes;
Box box1(5, 7, 8);
SomeBoxes.insert(box1);
Box box2(8, 7, 5);
SomeBoxes.insert(box2); // box1 == box2 in the set according to operator<
Box box3(7, 7, 7);
SomeBoxes.insert(box3);
Box box4(10, 14, 16);
SomeBoxes.insert(box4);
Box box5(3, 3, 3);
SomeBoxes.insert(box5);
```

自定义比较函数

```c++

```

> 遍历
>
> 查找：`find` 。
>
> ```c++
> std::set<int> evenNumbers = {0,2,4,6,8,10};
> if (evenNumber.find(5) == evenNumbers.end())
> std::cout << "Can't find 5 in evenNumber" << std::endl;
> else
> std::cout << "Can find 5 in evenNumber" << std::endl;
> ```
>
> 计数：`count` 。
>
> 添加：`insert` 。
>
> 删除：`erase` 。
>
> ```c++
> std::set<int> evenNumbers = {0,2,4,6,8,10};
> for(std::set<int>::iterator itr = ;;)
> {
>  
> }
> ```
>
> 

### map

```c++
typedef std::string Poet;    
typedef std::string Poem;    
std::multimap<Poet, Poem> poemCollection;
   
poemCollection.insert(std::pair<"李白", "将进酒">);
poemCollection.insert(std::pair<"李白", "蜀道难">);
poemCollection.insert(std::pair<"白居易", "琵琶行">);
poemCollection.insert(std::pair<"", "">);
```



无序关联容器是 C++ 11 标准。

若有序，按 `<` 对成员排列；

```c++

```

若无序，需定义成员的哈希函数。

```

```

### multi set / map

### unordered set / map

### unordered map

# 语句

语句，statement，是顺序执行的程序段。声明不是语句，因为不会有程序被执行。

## 语句的标号

标号，label，`语句的标号名: 语句内容` 。与 `goto` 、`case` 配合使用。

## 复合型语句

，又称块 block，由 `{ }` 括起来的多条语句构成。函数体

## 表达式型语句

## 选择型语句



## 迭代型语句

## 跳转型语句

`break;` 跳出当前的循环。

`continue;` 

`return 可选的表达式;`  

`goto 语句的标号;`  用于跳。

# 表达式



## 

# 函数

函数是有具体用途的自包含的**代码块**。函数也是对象，有类型、名、值。

* 函数的**类型**取决于**参数列表与返回类型**。
* 函数的实例对象**名称**取决于**函数名**。用来被标识与调用。
* 函数的**定义**取决于**函数体**。

函数声明，功能为：给外部提供调用接口。虽然参数列表可以省略参数名，但不建议，最好与函数定义保持一致。

函数定义，

函数重载。

函数调用栈。

内联函数。

友元函数。

# λ表达式

λ表达式，Lambda Expression，于 C++ 11 引入，在编程领域又名：匿名函数（Anonymous Functions）、闭包（Closure）。λ表达式之于函数，类似于字面值之于变量，都是有值无名的某个对象。

# 枚举

# 联合体

# 类和结构体

类与结构体

C 中结构体用于将。

C++ 中类与结构体。

## 嵌套类

嵌套类，Nested Class，指此类在其他类里定义。嵌套类是静态成员。

# 成员

类或结构体

# 继承

# 构造



# 析构



# 类型转换

使用以 `(typeName) variable` 形式，实现显式地类型转换。



# 多态

虚函数、纯虚函数、虚函数表、虚基类，

# 作用域

# 运算符

[运算符]:#运算符

## 运算符重载

# 内存管理

动态内存，又称为堆（heap）。

C 语言中，`stdlib.h` 。

# 断言

断言，Assert，在程序插入断言，只有断言内的表达式为真，程序才能继续运行，。通常断言只在调试模式中有效，会令调试版本的运行速度慢于发布版本。

# 异常

异常，exception，用于标志程序发生错误或意外。例如系统不能响应 `new` 的内存请求（如没有多余的内存），则将抛出一个异常。

由于异常会带来很大的系统开销，所以仅适用于致命错误（如读取磁盘错误），不适用于广泛的普通错误检查（如输入无效数据）。

异常使用三个关键字 `try` 、`throw` 、`catch`：

* `try` —— **尝试**运行某代码。
* `throw` —— 代码出错**抛出**异常。
* `catch` —— **捕获**某异常并处理该异常。

> 异常应用实例：
>
> ```c++
> 
> ```
>
> 

# 模板

### Class Templates 类模板

### Function Templates 函数模板

```c++
template< class T > void MySwap( T& a, T& b ) {
   T c(a);
   a = b;
   b = c;
}
```

# 输入输出

输入源自键盘输入或文件；输出到达打印显示或文件。

C 语言中，输入输出功能由 [\<stdio.h>](http://www.cplusplus.com/reference/cstdio/) 提供。



stream ，流，概念上，。



C++ 标准库提供的输入输出流头文件：

* `<iostream>` 
* `<fstream>`
* `<sstream>`

流没有赋值操作。

## 键盘输入终端输出



## 文件输入文件输出

C 使用 `<stdio.h>` 头文件。`FILE` ，`fopen` 、。

> C，文件的打开关闭
>
> ```C
> 
> ```

> C，将字符数据写入文件
>
> ```C
> 
> ```

> C，读取字符文件的数据，

> C，将二进制数据写入文件
>
> ```C
> File* pMyFile;
> 
> 
> 
> ```

> C，读取二进制文件的数据。
>
> ```C
> FILE *filePtr = NULL;	// 定义文件指针
> fseek					// 定位到文件末尾
> filePtr = fopen("/tmp/test.txt", "w+"); // 打开文件。打开方式为如果文件不存在就创建一个
> fputs("This is testing for fputs...\n", fp); // 往文件写入数据
> fclose(fp); // 关闭文件
> ```
>

C++ 使用 `<iostream>` 头文件。

## 格式化流

## 错误输出

## 日志输出

# 编译

编译单元，，是编译阶段。

**条件编译。**

**单次编译。** 预处理 once pragma 可以使此文件下的代码只编译一次。

------

**字节对齐编译。** 预处理 [pack pragma](https://docs.microsoft.com/en-us/cpp/preprocessor/pack?view=vs-2019) 可以设置结构体、类、联合体。

> 默认 4 字节对齐：
>
> ```c++
> sizeof(long long);	// 8 Bytes
> sizeof(int);		// 4 Bytes
> sizeof(char);		// 1 Byte
> struct S
> {
>     long long ll;	// 8 Bytes
>     int i1;			// 4 Bytes
>     char c;			// 4 Bytes		
>     int i2;			// 4 Bytes
> }
> sizeof(S);			// 24 Bytes
> ```
>
> 预处理设置 1 字节对齐：
>
> ```c++
> sizeof(long long);	// 8 Bytes
> sizeof(int);		// 4 Bytes
> sizeof(char);		// 1 Byte
> #pragma pack(1)
> struct S
> {
>     long long ll;	// 8 Bytes
>     int i1;			// 4 Bytes
>     char c;			// 4 Bytes		
>     int i2;			// 4 Bytes
> }
> sizeof(S);			// 24 Bytes
> ```

------



# 调试

# 时间

# STL 算法

> 参考
>
> [Youtube - 一小时内学习105种STL算法](https://www.youtube.com/watch?v=bFSnXNIsK4A)

## 排序 `sort `

[sort](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#sort) ，两种函数重载，可缺省使用 `<` 运算符作排序的比较；或传入比较函数变量，依据此函数排序。

1. 默认使用 `<` 运算符进行排序

```c++
std::vector<int> v1 = {8, 10, 15, 23, 55, 22, 78, 11, 28};
std::sort(v1.begin(), v1.end()); // 8 10 11 15 22 23 28 55 78
```

对于自定义类型，必须定义类型的 `<` 运算符。对于容器成员，若 `a < b == false && b < a == false` ，则 `a == b` 。

```c++
struct Box
{
    double length;
    double width;
    double height;
    double volume;
    Box(double l, double w, double h) : length(l), width(w), height(h)
    {
        volume = l * w * h;
    }
    bool operator<(const Box &other) const { return volume < (other.volume); }
};

std::vector<Box> SomeBoxes;
Box box1(5, 7, 8);
Box box2(1, 3, 5);
Box box3(7, 7, 7);
Box box4(10, 14, 16);
Box box5(3, 3, 3);
SomeBoxes.push_back(box1);
SomeBoxes.push_back(box2);
SomeBoxes.push_back(box3);
SomeBoxes.push_back(box4);
SomeBoxes.push_back(box5);

// SomeBoxes's volume sequence before sorted: 280 15 343 2240 27

std::sort(SomeBoxes.begin(), SomeBoxes.end());

// SomeBoxes's volume sequence after sorted: 15 27 280 343 2240
return 0;
```

2. 使用自定义比较函数进行排序

```c++
bool GreaterInt(int integer1, int integer2)
{
    return integer1 > integer2;
}
```

```c++
std::vector<int> v1 = {8, 10, 15, 23, 55, 22, 78, 11, 28};
std::sort(v1.begin(), v1.end(), GreaterInt); // 78 55 28 23 22 15 11 10 8
```

 [is_sorted](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted)

 [is_sorted_until](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#is_sorted_until)

# 数学

# 并行

C++11新特性。C++11标准库只定义了标准的线程管理，没有定义标准的进程管理。这使进程间的通讯依赖于平台操作系统的API。若为了更好移植性，应选择多线程而不是多进程。

> C++ 11 - 线程版 Hello World 程序
>
> ```c++
> #include <thread> // 声明了管理线程的函数和类的标准C++11头文件
> #include <iostream>
> void hello() // 作为线程的初始函数，被创建的线程从此函数开始运行
> {
>     std::cout << "Hello World" << std::endl;
> }
> int main() // 应用程序的初始线程从main函数开始运行
> {
>     std::thread t(Hello); // 在初始线程内创建一个标准线程类的对象，使用hello初始化，并启动
>     t.join(); // 只有子线程结束后主线程才可以结束，否则初始线程自顾继续运行，可能先于新线程结束。
>     return 0; 
> }
> ```

每个程序至少有一个线程执行main函数，其余线程则有各自的入口函数。











































~~C++ 11 是继 C++ 98 后的语言版本。~~

## ~~Lexical Conventions 法规则~~

> ~~一个输出 ”Hello Word“ 的 C++ 语句：~~
>
> ```c++
> std::cout << "Hello World!" << std::endl;
> ```
>
> ~~可拆解为以下令牌：~~
>
> 1. ~~`std` - 命名空间~~
> 2. 
> 3. 



### ~~Punctuator 标点~~

### ~~Comment 注释~~

```c++
// comment a line

/*
comment
a 
block
*/
```

## ~~Basic 基础~~

### ~~Type 类型~~



### ~~Scope 作用域~~

~~`{}`~~ 

### ~~Header File 头文件~~

### ~~Lvalue & Rvalue 左值 & 右值~~





## ~~

## ~~Declaration & Definition 声明 & 定义~~

~~Variable，变量，由 Type 类型、Name 变量名、Value 值 组成。~~

### ~~`typedef` 类型别名~~

## ~~casting 类型转换~~

## ~~Build-In Operation  内置运算符~~

| ~~优先级~~ |   ~~符号~~   | ~~中/英~~                                                    | ~~描述~~             |
| :--------: | :----------: | ------------------------------------------------------------ | -------------------- |
| ~~**1**~~  |   ~~`::`~~   | ~~作用域解析 / [Scope Resolution](https://docs.microsoft.com/en-us/cpp/cpp/scope-resolution-operator?view=vs-2019)~~ | ~~类/命名空间~~      |
| ~~**2**~~  |   ~~`.`~~    | ~~访问对象成员 / [Object Member Access)](https://docs.microsoft.com/en-us/cpp/cpp/member-access-operators-dot-and?view=vs-2019)~~ |                      |
|   ~~2~~    |   ~~`->`~~   | ~~访问指针成员 / [Pointer Member Access](https://docs.microsoft.com/en-us/cpp/cpp/member-access-operators-dot-and?view=vs-2019)~~ |                      |
|   ~~2~~    |   ~~`[]`~~   | ~~下标运算符 / [Subscript](https://docs.microsoft.com/en-us/cpp/cpp/subscript-operator?view=vs-2019)~~ |                      |
|   ~~2~~    |   ~~`()`~~   | ~~函数调用 / [Function call](https://docs.microsoft.com/en-us/cpp/cpp/function-call-operator-parens?view=vs-2019)~~ |                      |
|   ~~2~~    |   ~~`++`~~   | ~~后置递增 / [Postfix increment](https://docs.microsoft.com/en-us/cpp/cpp/postfix-increment-and-decrement-operators-increment-and-decrement?view=vs-2019)~~ |                      |
|   ~~2~~    |   ~~`--`~~   | ~~后置递减 / [Postfix decrement](https://docs.microsoft.com/en-us/cpp/cpp/postfix-increment-and-decrement-operators-increment-and-decrement?view=vs-2019)~~ |                      |
|   ~~2~~    |              |                                                              |                      |
|   ~~2~~    |              |                                                              |                      |
|   ~~2~~    |              |                                                              |                      |
|   ~~2~~    |              |                                                              |                      |
|   ~~2~~    |              |                                                              |                      |
| ~~**3**~~  | ~~`sizeof`~~ | ~~对象或类型占用字节 / [Size of object or type](https://docs.microsoft.com/en-us/cpp/cpp/sizeof-operator?view=vs-2019)~~ |                      |
|   ~~3~~    |  ~~`new`~~   | ~~创建对象 / [Create object](https://docs.microsoft.com/en-us/cpp/cpp/new-operator-cpp?view=vs-2019)~~ | ~~在动态内存中划分~~ |
|   ~~3~~    | ~~`delete`~~ | ~~销毁对象 / [Destroy object](https://docs.microsoft.com/en-us/cpp/cpp/delete-operator-cpp?view=vs-2019)~~ |                      |
|   ~~3~~    |              |                                                              |                      |
| ~~**4**~~  |              |                                                              |                      |
|            |              |                                                              |                      |
| ~~**5**~~  |              |                                                              |                      |
| ~~**6**~~  |              |                                                              |                      |
| ~~**7**~~  |              |                                                              |                      |
| ~~**8**~~  |              |                                                              |                      |
| ~~**9**~~  |              |                                                              |                      |
| ~~**10**~~ |              |                                                              |                      |
| ~~**11**~~ |              |                                                              |                      |
| ~~**12**~~ |              |                                                              |                      |
| ~~**13**~~ |              |                                                              |                      |
| ~~**14**~~ |              |                                                              |                      |
| ~~**15**~~ |              |                                                              |                      |
| ~~**16**~~ |              |                                                              |                      |
| ~~**17**~~ | ~~`throw`~~  |                                                              |                      |
| ~~**18**~~ |   ~~`,`~~    |                                                              |                      |

## ~~Expression 表达式~~

~~类型转换~~

```c++

```



## ~~Statement 语句~~

### ~~Selection (Branch) 选择（分支）~~

### ~~Iteration (Loop) 迭代（循环）~~

## ~~Pointer 指针~~



### ~~`void` pointer~~

### ~~`NULL` pointer~~

### ~~pointer to pointer~~

## ~~Array 数组~~



## ~~Reference 引用~~

~~引用，Reference，是 C++ 语法做的优化，编译后，**本质还是靠指针**来实现的。引用相当于变量的别名。~~

## ~~Function 函数~~

### ~~Argument List  参数表~~



> ~~**拓展**：C 标准库头文件 `<stdarg.h>` 或 C++ 标准库头文件 `<initializer_list>` 可用于实现**参数个数可变**。~~

### ~~overload 重载~~



### ~~inline 内联~~

### ~~Pointer to Function 函数指针~~

### ~~Callback Function 回调函数~~

~~通过函数指针~~

## ~~Lambda (Closure) 闭包~~

~~lambda 就是一种匿名函数，没有函数名的某种，又称为 closure，闭包。~~

## ~~Enumeration 枚举~~

~~枚举用于定义只有几种有限可能的类型。~~

 ```c++
enum Suit // Suit is Enumeration
{
    // heart etc. is Enumerator
    heart,   /*♥️*/ 
    spade,   /*♠️*/
    club,    /*♣️*/
    diamond  /*♦️*/
}

void checkSuit(Suit suit)
{
    // Enumeration always match with switch brach.
    switch (suit)
    {
        case heart:
            /**/
            break;
            
            
            
    }
}
 ```

## ~~Union 联合~~

~~Union 联合，继承自 C 语言。~~

## ~~Class & Struct 类 & 结构~~

### ~~Define Class/Struct 定义类/结构~~



~~在 C 中，定义一个结构实例需写 `struct TypeName instanceName` ；在 C++ 中，可省略 `struct` 关键字写 `TypeName instanceName` 。~~

### ~~member 成员~~

### ~~member function 成员函数~~



#### ~~`this` 指针~~

~~`this` 指针指向~~ 

### ~~Constructor & Initialization 构造函数 & 初始化~~

~~构造函数用于~~

```c++
struct Fahrenheit
{
    double temperature;
    Fahrenheit(double Celsius)
}
```

#### ~~初始化列表~~

```c++
{
    
}
```



#### ~~Copy Constructor 拷贝构造函数~~



#### ~~Move Constructor 移动构造函数~~

~~C++ 11 新特性。~~

### ~~Destructor 析构函数~~

~~因为被系统调用，无参数表，所以无重载。~~

### ~~Access Control 访问控制~~

### ~~Inheritance 继承~~



#### ~~Override 重写~~



#### ~~Virtual Function 虚函数~~

~~开发者希望在派生类中被重新定义的成员函数应被声明为虚函数。~~



~~虚函数表~~

#### ~~Abstract Class 抽象类~~



#### ~~Single Base Class Inheritance 单基类继承~~



#### ~~Multiple Base Classes Inheritance 多基类继承~~



### ~~Static 静态~~ 

## ~~Operator Overloading 运算符重载~~

~~设计运算符重载是，应遵循逻辑。语法如下：~~

```c++
type operator operator-symbol ( parameter-list )
```

### ~~Unary 一元运算符~~

~~可被重载的一元运算符： `!` ` &` ` ~` ` *` ` +` ` -` ` ++`  `--` 。~~

### ~~Binary 二元运算符~~

```c++
struct Box
{
    unsigned int length;
    unsigned int height;
    unsigned int width;
};

bool operator<(const Box &lhs, const Box &rhs)
{
    return (lhs.length * lhs.height * lhs.width) < (rhs.length * rhs.height * rhs.width);
}

bool operator>(const Box &lhs, const Box &rhs)
{
    return (lhs.length * lhs.height * lhs.width) > (rhs.length * rhs.height * rhs.width);
}

int main()
{
    Box myBox, yourBox;
    myBox.length = 2;
    myBox.height = 2;
    myBox.width = 2;
    yourBox.length = 1;
    yourBox.height = 1;
    yourBox.width = 1;

    myBox < yourBox; // false
    myBox > yourBox; // true

    return 0;
}
```

## ~~Exception 异常~~

## ~~Assertion & Debug 断言与调试~~

~~在 C++ 程序的三个生命周期：预处理（preprocessing）、编译（compile）、运行时（runtime），分别有以下。~~

* 
* 

~~`Assert(oughtToBeTrueExpression)` 是一个宏定义，~~

## ~~Preprocessor 预处理~~

~~[C/C++ 预处理](https://docs.microsoft.com/en-us/cpp/preprocessor/c-cpp-preprocessor-reference)~~ 

### ~~条件编译~~

## ~~Compile 编译~~

~~编译器将 `.cpp` 和 `.h` 的 C++ 文本代码历经4个步骤： Preprocessing 预处理 →  Compilation → Assemble → Linking 链接，生成可执行文件（Executable File）或库（Library）。~~

### ~~Environment 环境~~

#### ~~GCC~~

~~[GCC](https://gcc.gnu.org/)，下载 。Windows 通过 MinGW 安装；macOS 通过 Homebrew 安装。~~

1. ~~下载MinGW：[官网地址](http://www.mingw.org/)~~
2. ~~安装MinGW：[默认位置](file:///C:/MinGW)~~
3. ~~修改环境变量：~~
   1. ~~计算机—属性---高级系统设置---环境变量，~~
   2. ~~在系统变量中找到 Path 变量，~~
   3. ~~在后面加入 min-gw的安装目录，如 [C:\MinGw\bin](file:///C:/MinGw/bin)~~
4. ~~验证：如果在cmd输入“mingw-get”能弹出MinGw     sinstallation manager 窗口，则安装成功~~
5. ~~安装gcc：cmd中输入“mingw-get install     gcc”，gcc用于编译.c文件~~
6. ~~安装g++：cmd中输入“mingw-get install g++”，g++用于编译.cpp文件~~
7. ~~安装gdb：cmd中输入“mingw-get install gdb”，gdb用于编译时调试~~
8. ~~编译.c文件：cmd中输入“gcc XXX.c”，将当前文件夹下XXX.c编译成a.exe文件~~
9. ~~调试程序：cmd中输入“gdb a.exe”，就可以是用gdb常用的命令进行调试程序了~~
10. ~~更新MinGW：cmd中输入“mingw-get update”,cmd中输入“mingw-get upgrade”~~

> ~~备注~~
>
> * ~~如果出现 Windows 平台下控制台乱码，则前往 `MinGW\share\locale` ，删除中文环境。~~

#### ~~Clang & LLVM~~

1. ~~下载LLVM：[官网地址](http://releases.llvm.org/download.html)，选择Pre-Built     Binaries中的Clang for Windows (64-bit)，获得exe文件~~
2. ~~运行exe文件，勾选Add LLVM to the     system PATH for all users（即第二项）。[默认位置](file:///C:/Program Files/LLVM)~~
3. ~~验证：cmd中输入“clang -v”，显示clang版本，则安装成功~~
4. ~~编译.c文件：cmd中输入“clang XXX.c”，将当前文件夹下XXX.c编译成a.exe文件~~

#### ~~Microsoft Visual C++~~

#### ~~Apple Xcode~~

~~Xcode IED 使用 LLVM 编译 C 家族语言。~~

### ~~Multiple Files Project 多文件工程~~

# ~~Standard Library 标准库~~

> ~~**参考**~~
>
> ~~[Microsoft Docs - C++ Standard Library](https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-reference)~~ 
>
> ~~[Microsoft Docs - C++ standard library header files](https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-header-files)~~

~~C++ Standard Library ，C++ 标准库。命名空间位于 `namespace std` 。~~

## ~~C 标准库~~

~~C 标准库是 C++ 标准库的子集。~~

### ~~"string.h" 字符数组~~

 ~~头文件 "string.h"。定义了 `sting` 结构体，以 `\0` 结尾的字符数组。~~ 

```c++
sizeof("ABC"); // = 4, beacuse of ending with `\0`;
memset();
```

### ~~"time.h" 时间~~



## ~~String 字符串~~



### ~~\<string\> 字符串模板类~~

~~头文件 [\<string\>](https://docs.microsoft.com/en-us/cpp/standard-library/string) 。~~

```c++
std::string myName = "";
```



~~`char*` 与 `std::string` 的转换~~

|                            | ~~to `string`~~ | ~~to `const char*`~~ | ~~to `char*`~~ | ~~to `char[]`~~ |
| -------------------------- | --------------- | -------------------- | -------------- | --------------- |
| ~~**from** `string`~~      |                 |                      |                |                 |
| ~~**from** `const char*`~~ |                 |                      |                |                 |
| ~~**from** `char*`~~       |                 |                      |                |                 |
| ~~**from** `char[]`~~      |                 |                      |                |                 |



# ~~I/O Stream 输入输出流~~

~~stream，流，具有输入/输出功能。stream 对象是一串有方向的字节包裹，具有 source 源头、destination 目的地。文件、控制台、字符串变量的读/写，会对 stream 对象进行操作。~~

## ~~string stream 字符串流~~

```

```

## ~~file stream 文件流~~

~~头文件 \<fstream\>  。 `class ifstream` 支持将 stream 输入/输出到文件，~~

# ~~Iterators 迭代器~~

~~[Iterators](https://docs.microsoft.com/en-us/cpp/standard-library/iterators)，迭代器，~~



## ~~Algorithms 算法~~

~~Algorithms ，算法，由 100+ 个函数组成。泛型编程使算法函数可应用于多种数据结构。头文件 [\<algorithm\>](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm) 。~~



### ~~copy 复制~~

### ~~find 寻找~~

### ~~fill 填充~~

### ~~replace 替换~~

### ~~Lexicographical 字典序~~

~~字典排序规则：从首位比较，若相等，则比较下一位。~~

### ~~permutation 全排列~~

~~[next_permutation](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#next_permutation) 与 [prev_permutation](https://docs.microsoft.com/en-us/cpp/standard-library/algorithm-functions?view=vs-2019#prev_permutation) 可用于获取上一个/下一个全排列。以 {A,B,C} 为例理解 next 与 previous 的含义：按字符 A<B<C 为小到大顺序的三者，排列数有 $A_3^3=\frac{3!}{(3-3)!}=6$ 种。这 6 种小到大排序为：ABC<ABC<BAC<BCA<CAB<CBA，这种排序称为**字典排序（lexicographical order）** 。~~

~~参数 first iteration、last iteration 指明在此 iterator 之间计算上/下个全排列，必须是顺序类型的 iterator。`bool` 型返回值，`true` 表示还有下一个全排列，`false` 表示已经没有下一个。 若缺省了比较函数，则默认使用 `<` 运算符比较，否则需传入比较函数。~~

```c++
std::string strABC = "ABC";
do{
    std::cout << strABC << " ";        
}while(std::next_permutation(strABC.begin(), strABC.end()));
// output: ABC ACB BAC BCA CAB CBA
```

## ~~memory management 内存管理~~ 

### ~~Smart Pointer 智能指针~~

## ~~Time 时间~~

~~头文件 [\<ctime\>](https://docs.microsoft.com/en-us/cpp/standard-library/ctime) 源于 C 标准库 time.h；头文件 [\<chrono\>](https://docs.microsoft.com/en-us/cpp/standard-library/chrono) 属于 C++ 标准库。~~

### ~~ctime~~

```

```



### ~~chrono~~

# ~~Debug 调试~~

## ~~GDB~~ 



[标识符]: 

[标点符号]: 